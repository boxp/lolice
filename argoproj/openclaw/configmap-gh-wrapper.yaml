apiVersion: v1
kind: ConfigMap
metadata:
  name: gh-wrapper
  namespace: openclaw
data:
  gh: |
    #!/bin/sh
    # gh-wrapper: subcommand-level access control for the GitHub CLI.
    # Mounted read-only from ConfigMap and placed ahead of the real gh
    # binary via pathPrepend so that OpenClaw's safeBins allowlist
    # delegates safety to this script rather than to token scopes.
    #
    # Policy:
    #   pr    — all subcommands EXCEPT merge
    #   issue — all subcommands
    #   auth  — status only
    #   run   — list | view
    #   api   — GET only (default method)
    #   api graphql — queries allowed; mutations allowlisted to issue/project ops
    #
    # Everything else is rejected with a non-zero exit code.

    set -eu

    REAL_GH="/usr/bin/gh"

    die() { printf 'gh-wrapper: denied — %s\n' "$1" >&2; exit 126; }

    if [ $# -eq 0 ]; then
      die "no subcommand provided"
    fi

    # Collect gh global options so they can be re-injected into the
    # real gh invocation after subcommand validation.
    GLOBAL_OPTS=""
    while [ $# -gt 0 ]; do
      case "$1" in
        -R|--repo)
          GLOBAL_OPTS="$GLOBAL_OPTS $1 $2"
          shift 2
          ;;
        -R=*|--repo=*)
          GLOBAL_OPTS="$GLOBAL_OPTS $1"
          shift
          ;;
        --help|--version)
          exec "$REAL_GH" "$@"
          ;;
        -*)
          die "unsupported global option '$1'"
          ;;
        *)
          break
          ;;
      esac
    done

    if [ $# -eq 0 ]; then
      die "no subcommand provided"
    fi

    cmd="$1"; shift

    # shellcheck disable=SC2086
    case "$cmd" in
      auth)
        [ "${1:-}" = "status" ] || die "auth: only 'status' is allowed"
        exec "$REAL_GH" $GLOBAL_OPTS auth "$@"
        ;;
      pr)
        sub="${1:-}"
        case "$sub" in
          merge) die "pr: 'merge' is explicitly denied" ;;
          "") die "pr: no subcommand provided" ;;
          *) shift; exec "$REAL_GH" $GLOBAL_OPTS pr "$sub" "$@" ;;
        esac
        ;;
      run)
        sub="${1:-}"
        case "$sub" in
          list|view) shift; exec "$REAL_GH" $GLOBAL_OPTS run "$sub" "$@" ;;
          *) die "run: '$sub' is not allowed (allowed: list, view)" ;;
        esac
        ;;
      issue)
        exec "$REAL_GH" $GLOBAL_OPTS issue "$@"
        ;;
      api)
        # Detect GraphQL endpoint: only match the first positional argument.
        # Skip option flags and their values so that e.g. --jq graphql
        # does not incorrectly trigger the GraphQL path (P1 fix).
        is_graphql=false
        _skip_val=false
        for arg in "$@"; do
          if $_skip_val; then
            _skip_val=false
            continue
          fi
          case "$arg" in
            -X|--method|-H|--header|-f|--raw-field|-F|--field|\
            -q|--jq|-t|--template|--input|--hostname|--cache|-p|--preview)
              _skip_val=true ;;
            -*) ;;
            *)
              [ "$arg" = "graphql" ] && is_graphql=true
              break ;;
          esac
        done

        if $is_graphql; then
          # --- GraphQL path ---
          # Queries are allowed freely.
          # Mutations are allowlisted to issue/project operations.
          # Only -f/--raw-field with query=, variables=, operationName= permitted.
          # -F/--field rejected (supports @file which bypasses query parsing).
          # --input rejected (file/stdin bypass).
          query_str=""
          prev_f=""
          for arg in "$@"; do
            case "$prev_f" in
              -f|--raw-field)
                case "$arg" in
                  query=@*|variables=@*|operationName=@*)
                    die "api graphql: file references (@) are not allowed" ;;
                  query=*) query_str="${arg#query=}" ;;
                  variables=*|operationName=*) ;;
                  *) die "api graphql: field '$arg' is not allowed (only query, variables, operationName)" ;;
                esac
                prev_f=""; continue ;;
            esac
            case "$arg" in
              -f|--raw-field) prev_f="$arg" ;;
              -fquery=@*|--raw-field=query=@*)
                die "api graphql: file references (@) are not allowed" ;;
              -fquery=*) query_str="${arg#-fquery=}" ;;
              --raw-field=query=*) query_str="${arg#--raw-field=query=}" ;;
              -fvariables=*|--raw-field=variables=*) ;;
              -foperationName=*|--raw-field=operationName=*) ;;
              -f*|--raw-field=*)
                die "api graphql: only query, variables, operationName fields are allowed" ;;
              -F|--field|-F*|--field=*)
                die "api graphql: use -f/--raw-field instead of -F/--field" ;;
              --input|--input=*)
                die "api graphql: --input is not allowed" ;;
              *) ;;
            esac
          done

          # Normalize whitespace (newlines/tabs → spaces, collapse runs, strip leading)
          # Note: we intentionally do NOT strip GraphQL comments (#...) because
          # doing so could erase content inside string literals (e.g. "foo#bar")
          # and allow a mutation keyword to be hidden from detection.
          normalized=$(printf '%s' "$query_str" | tr '\n\r\t' '   ' | sed 's/  */ /g; s/^[[:space:]]*//')
          # Strip string literals before mutation detection to avoid false
          # positives from "mutation" appearing inside string values (P2 fix).
          # Handles block strings ("""..."""), escaped quotes (\"), and
          # regular strings ("...") via character-by-character scanning.
          stripped=$(printf '%s' "$normalized" | awk '{
            r=""; s=$0
            while (length(s) > 0) {
              if (substr(s,1,3) == "\"\"\"") {
                s = substr(s,4)
                while (length(s) > 0) {
                  if (substr(s,1,1) == "\\" && substr(s,2,3) == "\"\"\"") {
                    s = substr(s,5)
                  } else if (substr(s,1,3) == "\"\"\"") {
                    s = substr(s,4); break
                  } else { s = substr(s,2) }
                }
              } else if (substr(s,1,2) == "\\\"") {
                s = substr(s,3)
              } else if (substr(s,1,1) == "\"") {
                s = substr(s,2)
                while (length(s) > 0 && substr(s,1,1) != "\"") {
                  if (substr(s,1,2) == "\\\"") s = substr(s,3)
                  else s = substr(s,2)
                }
                if (length(s) > 0) s = substr(s,2)
              } else {
                r = r substr(s,1,1); s = substr(s,2)
              }
            }
            printf "%s", r
          }')
          # Check for mutation keyword anywhere in the document (word boundary)
          if printf '%s' "$stripped" | grep -qE '(^|[^a-zA-Z0-9_])mutation([[:space:]{(]|$)'; then
            # mutation keyword found — require it to be the first operation
            case "$stripped" in
              mutation*) ;; # OK — mutation is the first operation
              *) die "api graphql: mutation must be the first operation in the document" ;;
            esac
            # Extract top-level mutation field names.
            # 1. Get content after the first '{' (the selection set).
            inner=$(printf '%s' "$stripped" | sed 's/^[^{]*{//')
            # 2. Collapse nested {...} to isolate top-level fields.
            depth_zero="$inner"
            while true; do
              new=$(printf '%s' "$depth_zero" | sed 's/{[^{}]*}//g')
              [ "$new" = "$depth_zero" ] && break
              depth_zero="$new"
            done
            # 3. Extract identifiers immediately before '(' — these are
            #    mutation names (aliases precede ':', not '(').
            mut_names=$(printf '%s' "$depth_zero" \
              | grep -oE '[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]*\(' \
              | sed 's/[[:space:]]*($//' || true)
            [ -z "$mut_names" ] && die "api graphql: could not parse mutation name(s)"
            for m in $mut_names; do
              case "$m" in
                addComment|updateIssueComment|deleteIssueComment|\
                createIssue|updateIssue|closeIssue|reopenIssue|deleteIssue|\
                transferIssue|markIssueAsDuplicate|unmarkIssueAsDuplicate|\
                addLabelsToLabelable|removeLabelsFromLabelable|\
                addAssigneesToAssignable|removeAssigneesFromAssignable|\
                lockLockable|unlockLockable|pinIssue|unpinIssue|\
                createProjectV2|updateProjectV2|deleteProjectV2|copyProjectV2|\
                addProjectV2ItemById|updateProjectV2ItemFieldValue|\
                clearProjectV2ItemFieldValue|deleteProjectV2Item|\
                archiveProjectV2Item|unarchiveProjectV2Item|\
                updateProjectV2ItemPosition|\
                addProjectV2DraftIssue|updateProjectV2DraftIssue|deleteProjectV2DraftIssue|\
                linkProjectV2ToRepository|unlinkProjectV2FromRepository|\
                linkProjectV2ToTeam|unlinkProjectV2FromTeam|\
                createProjectV2Field|updateProjectV2Field|deleteProjectV2Field|\
                createProjectV2StatusUpdate|updateProjectV2StatusUpdate|deleteProjectV2StatusUpdate)
                  ;; # allowed
                *)
                  die "api graphql: mutation '$m' is not in the allowlist"
                  ;;
              esac
            done
          fi
          exec "$REAL_GH" $GLOBAL_OPTS api "$@"
        fi

        # --- Non-GraphQL API: GET only (existing logic, unchanged) ---
        method="GET"
        for arg in "$@"; do
          case "$arg" in
            --method=*)
              method="${arg#*=}"
              ;;
            --method|-X)
              # value follows in next arg — resolved in second pass
              ;;
            -X*)
              # concatenated form: -XPOST, -XGET, etc.
              method="${arg#-X}"
              ;;
            --input|--input=*)
              die "api: --input is not allowed (implies write operation)"
              ;;
            -f|--raw-field|-f*|--raw-field=*)
              die "api: -f/--raw-field is not allowed (triggers implicit POST)"
              ;;
            -F|--field|-F*|--field=*)
              die "api: -F/--field is not allowed (triggers implicit POST)"
              ;;
          esac
        done
        # Second pass: resolve -X / --method <value> (separate arg form)
        prev=""
        for arg in "$@"; do
          if [ "$prev" = "--method" ] || [ "$prev" = "-X" ]; then
            method="$arg"
          fi
          prev="$arg"
        done
        case "$method" in
          GET|get) ;;
          *) die "api: method '$method' is not allowed (only GET)" ;;
        esac
        exec "$REAL_GH" $GLOBAL_OPTS api "$@"
        ;;
      *)
        die "'$cmd' is not an allowed subcommand"
        ;;
    esac
